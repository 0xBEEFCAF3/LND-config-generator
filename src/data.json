{
  "__internal": {
    "platform": {
      "name": "Platform",
      "description": {
        "Linux": "Config for Linux",
        "Mac OS": "Config for Mac OS"
      },
      "default": null,
      "values": ["Linux", "Mac OS"]
    }
  },
  "chain": {
    "section": "Chain Selection",
    "description": "Choose which network / blockchain to use.",
    "chain": {
      "name": "Chain",
      "description": "Run this node on the given network.",
      "description": {
        "main": "Main Network",
        "test": "Test Network.",
        "regtest": "Regression Test Network"
      },
      "default": "main",
      "values": [
        "Mainnet [main]",
        "Testnet [test]",
        "Regtest [regtest]"
      ]
    },
    "testnet": {
      "name": "Testnet",
      "description": "Run this node on the Bitcoin Test Network. Equivalent to -chain=test",
      "default": 0
    },
    "regtest": {
      "name": "Regtest",
      "description": "Run this node on its own independent test network. Equivalent to -chain=regtest",
      "default": 0
    },
    "signet": {
      "name": "Signet",
      "description": "Use the signet chain. Equivalent to -chain=signet. Note that the network is defined by the -signetchallenge parameter",
      "default": 0
    },
    "signetchallenge": {
      "name": "Signet Challenge",
      "description": "Blocks must satisfy the given script to be considered valid (only for signet networks)"
      
    },
    "signetseednode": {
      "name": "Signet Seed Node",
      "description": "Specify a seed node for the signet network, in the hostname[:port] format, e.g. sig.net:1234 (may be used multiple times to specify multiple seed nodes)"
    },
    "vbparams": {
      "name": "Version Bits Deployment Params",
      "description": "Use given start/end times for specified version bits deployment. Regtest mode only, in format <deployment:start:end[:min_activation_height]>. Can be set multiple times.",
      "default": ""
    }
  },
  "app": {
    "section": "Application Configs",
    "description": "Basic parameters regarding LND node operation.",
    "datadir": {
      "name": "Data Dir",
      "description": "The directory that lnd stores all wallet, chain, and channel related data",
      "default": "~/.lnd/data"
    },
    "logdir": {
      "name": "Log Dir",
      "description": "The directory that logs are stored in. The logs are auto-rotated by default. Rotated logs are compressed in place.",
      "default": "~/.lnd/logs"
    },
    "maxlogfiles": {
      "name": "Max Log Files",
      "description": "Number of logfiles that the log rotation should keep. Setting it to 0 disables deletion of old log files.",
      "default": 3
    },
    "maxlogfilesize": {
      "name": "Max Log File Size",
      "description": "Max log file size in MB before it is rotated.",
      "default": ""
    },
    "acceptortimeout": {
      "name": "Acceptor Timeout",
      "description": "Time after which an RPCAcceptor will time out and return false if it hasn't yet received a response.",
      "default": "15s"
    },
    "tlscertpath": {
      "name": "TLS Cert Path",
      "description": "Path to TLS certificate for lnd's RPC and REST services.",
      "default": "~/.lnd/tls.cert"
    },
    "tlskeypath": {
      "name": "TLS Private Key Path",
      "description": "Path to TLS private key for lnd's RPC and REST services.",
      "default": "~/.lnd/tls.key"
    },
    "tlsextraip": {
      "name": "Tls Extra IP",
      "description": "Adds an extra ip to the generated certificate. Setting multiple tlsextraip= entries is allowed.",
      "default": ""
    },
    "tlsextradomain": {
      "name": "Tls Extra domain",
      "description": "Adds an extra domain to the generate certificate. Setting multiple tlsextradomain= entries is allowed.",
      "default": ""
    },
    "tlsautorefresh": {
      "name": "Tls auto refresh",
      "description": "The duration from generating the self signed certificate to the certificate expiry date. Valid time units are {s, m, h}. The below value is about 14 months (14 * 30 * 24 = 10080)",
      "default": "10080h"
    },
    "tlscertduration": {
      "name": "Publish Hash Sequence Message High Water Mark",
      "description": "If set, then all certs will automatically be refreshed if they're close to expiring, or if any parameters related to extra IPs or domains in the cert change.",
      "default": ""
    },
    "tlsdisableautofill": {
      "name": "Tls disable auto fill",
      "description": "Do not include the interface IPs or the system hostname in TLS certificate, use first --tlsextradomain as Common Name instead, if set.",
      "default": true
    },
    "externalhosts": {
      "name": "External Hosts",
      "description": "A list of domains for lnd to periodically resolve, and advertise the resolved. IPs for the backing node. This is useful for users that only have a dynamic IP, or want to expose the node at a domain.",
      "default": "my-node-domain.com"
    },
    "letsencryptdir": {
      "name": "Lets encrypt dir",
      "description": "Lets the directory to store Let's Encrypt certificates within",
      "default": "~/.lnd/letsencrypt"
    },
    "letsencryptlisten": {
      "name": "Lets encrypt listen",
      "description": "The IP:port on which lnd will listen for Let's Encrypt challenges.",
      "default": "localhost:8080"
    },
    "letsencryptdomain": {
      "name": "Lets encrypt domain",
      "description": "Request a Let's Encrypt certificate for this domain. Note that the certificate is only requested and stored when the first rpc connection comes in.",
      "default": "example.com"
    },
    "no-macaroons": {
      "name": "No macaroons",
      "description": "Disable macaroon authentication. Macaroons are used as bearer credentials to authenticate all RPC access",
      "default": false
    },
    "sync-freelist": {
      "name": "Sync Fee List",
      "description": "Enable free list syncing for the default bbolt database. This will decrease start up time, but can result in performance degradation for very large databases, and also result in higher memory usage. If \"free list corruption\" is detected, then this flag may resolve things.",
      "default": true
    },
    "adminmacaroonpath": {
      "name": "Admin Macaroon Path",
      "description": "Path to write the admin macaroon for lnd's RPC and REST services if it doesn't exist",
      "default": "~/.lnd/data/chain/bitcoin/simnet/admin.macaroon"
    },
    "readonlymacaroonpath": {
      "name": "Read only macaroon",
      "description": "Path to write the read-only macaroon for lnd's RPC and REST services if it doesn't exist.",
      "default": "~/.lnd/data/chain/bitcoin/simnet/readonly.macaroon"
    },
    "invoicemacaroonpath": {
      "name": "invoice macaroon path",
      "description": "Path to write the invoice macaroon for lnd's RPC and REST services if it doesn't exist.",
      "default": "~/.lnd/data/chain/bitcoin/simnet/invoice.macaroon"
    },
    "coin-selection-strategy": {
      "name": "Coin Selection Strategy",
      "description": "The strategy to use for selecting coins for wallet transactions. Options are 'largest' and 'random'.",
      "default": "largest"
    },
    "payments-expiration-grace-period": {
      "name": "Payments expiration grace period",
      "description": " A period to wait before for closing channels with outgoing htlcs that have timed out and are a result of this nodes instead payment. Valid time units are {s, m, h}.",
      "default": true
    },
    "listen": {
      "name": "Listen",
      "description": "Specify the interfaces to listen on for p2p connections. One listen address per line.",
      "default": "0.0.0.0:9735"
    },
    "nolisten": {
      "name": "No Listen",
      "description": "Disable listening for incoming p2p connections. This will override all listeners.",
      "default": false
    },
    "rpclisten": {
      "name": "RPC Listen",
      "description": "Specify the interfaces to listen on for gRPC connections. One listen address per line.",
      "default": "localhost:10009"
    },
    "restlisten": {
      "name": "REST Listen",
      "description": "Specify the interfaces to listen on for REST connections. One listen address per line.",
      "default": "0.0.0.0:8080"
    },
    "restcors": {
      "name": "REST CORS",
      "description": "A series of domains to allow cross origin access from. This controls the CORs policy of the REST RPC proxy.",
      "default": ""
    },
    "externalip": {
      "name": "External Ip",
      "description": "Adding an external IP will advertise your node to the network. This signals that your node is available to accept incoming channels. If you don't wish to advertise your node, this value doesn't need to be set.",
      "default": ""
    },
    "nat": {
      "name": "NAT",
      "description": "Instead of explicitly stating your external IP address, you can also enable UPnP or NAT-PMP support on the daemon.",
      "default": false
    },
    "norest": {
      "name": "No REST",
      "description": "Disable REST API.",
      "default": false
    },
    "no-rest-tls": {
      "name": "No REST TLS",
      "description": "Disable TLS for the REST API.",
      "default": false
    },
    "addpeer": {
      "name": "Add Peer",
      "description": "Specify peer(s) to connect to first.",
      "default": ""
    },
    "ws-ping-interval": {
      "name": "WS Ping Interval",
      "description": "The ping interval for REST based WebSocket connections, set to 0 to disable sending ping messages from the server side. Valid time units are {s, m, h}.",
      "default": ""
    },
    "ws-pong-wait": {
      "name": "WS Pong Wait",
      "description": "The time we wait for a pong response message on REST based WebSocket connections before the connection is closed as inactive. Valid time units are {s, m, h}.",
      "default": ""
    },
    "minbackoff": {
      "name": "Min Backoff",
      "description": "Shortest backoff when reconnecting to persistent peers. Valid time units are {s, m, h}.",
      "default": ""
    },
    "maxbackoff": {
      "name": "Max Backoff",
      "description": "Longest backoff when reconnecting to persistent peers. Valid time units are {s, m, h}.",
      "default": ""
    },
    "connectiontimeout": {
      "name": "Connection Timeout",
      "description": "The timeout value for network connections in seconds, default to 120 seconds. Valid uints are {ms, s, m, h}.",
      "default": ""
    },
    "debuglevel": {
      "name": "Debug Level",
      "description": "Debug logging level. Valid levels are {trace, debug, info, warn, error, critical}",
      "default": "debug"
    },
    "cpuprofile": {
      "name": "CPU Profile",
      "description": "Write CPU profile to the specified file.",
      "default": ""
    },
    "profile": {
      "name": "Profile",
      "description": "Enable HTTP profiling on given port -- NOTE port must be between 1024 and 65536. The profile can be access at: http://localhost:<PORT>/debug/pprof/.",
      "default": ""
    },
    "unsafe-replay": {
      "name": "Unsafe Replay",
      "description": "Causes a link to replay the adds on its commitment txn after starting up, this enables testing of the sphinx replay logic.",
      "default": ""
    },
    "maxpendingchannels": {
      "name": "Max Pending Channels",
      "description": "The maximum number of incoming pending channels permitted per peer.",
      "default": "1"
    },
    "backupfilepath": {
      "name": "Backup file Path",
      "description": "The target location of the channel backup file.",
      "default": ""
    },
    "blockcachesize": {
      "name": "Block Cache Size",
      "description": "The maximum capacity of the block cache in bytes. Increasing this will result in more blocks being kept in memory but will increase performance when the same block is required multiple times.",
      "default": ""
    },
    "feeurl": {
      "name": "Fee Url",
      "description": "Optional URL for external fee estimation. If no URL is specified, the method for fee estimation will depend on the chosen backend and network. Must be set for neutrino on mainnet.",
      "default": ""
    },
    "nobootstrap": {
      "name": "No Boot Strap",
      "description": "If true, then automatic network bootstrapping will not be attempted. This means that your node won't attempt to automatically seek out peers on the network",
      "default": false
    },
    "noseedbackup": {
      "name": "No Seed Backup",
      "description": "If true, NO SEED WILL BE EXPOSED -- EVER, AND THE WALLET WILL BE ENCRYPTED USING THE DEFAULT PASSPHRASE. THIS FLAG IS ONLY FOR TESTING AND SHOULD NEVER BE USED ON MAINNET.",
      "default": false
    },
    "wallet-unlock-password-file": {
      "name": "Wallet Unlock Password File",
      "description": "The full path to a file (or pipe/device) that contains the password for \n;unlocking the wallet; if set, no unlocking through RPC is possible and lnd\n; will exit if no wallet exists or the password is incorrect; if\n; wallet-unlock-allow-create is also set then lnd will ignore this flag if no\n; wallet exists and allow a wallet to be created through RPC.",
      "default": ""
    },
    "wallet-unlock-allow-create": {
      "name": "Wallet Unlock Allow Create",
      "description": "Don't fail with an error if wallet-unlock-password-file is set but no wallet\n; exists yet. Not recommended for auto-provisioned or high-security systems\n; because the wallet creation RPC is unauthenticated and an attacker could\n; inject a seed while lnd is in that state.",
      "default": ""
    },
    "reset-wallet-transactions": {
      "name": "Reset Wallet Transactions",
      "description": "Removes all transaction history from the on-chain wallet on startup, forcing a\n; full chain rescan starting at the wallet's birthday. Implements the same\n; functionality as btcwallet's dropwtxmgr command. Should be set to false after\n; successful execution to avoid rescanning on every restart of lnd.",
      "default": ""
    },
    "minchansize": {
      "name": "Minimum Channel Size",
      "description": "The smallest channel size (in satoshis) that we should accept. Incoming channels smaller than this will be rejected, default value 20000.",
      "default": ""
    },
    "maxchansize": {
      "name": "Max Channel Size",
      "description": "The largest channel size (in satoshis) that we should accept. Incoming channels larger than this will be rejected. For non-Wumbo channels this limit remains 16777215 satoshis by default as specified in BOLT-0002.",
      "default": ""
    },
    "coop-close-target-confs": {
      "name": "Coopertive Close Target Confirmations",
      "description": "The target number of blocks in which a cooperative close initiated by a remote\n; peer should be confirmed. This target is used to estimate the starting fee\n; rate that will be used during fee negotiation with the peer. This target is\n; is also used for cooperative closes initiated locally if the --conf_target\n; for the channel closure is not set.",
      "default": ""
    },
    "channel-commit-interval": {
      "name": "Channel Commit Interval",
      "description": "The maximum time that is allowed to pass between receiving a channel state\n; update and signing the next commitment. Setting this to a longer duration\n; allows for more efficient channel operations at the cost of latency.",
      "default": ""
    },
    "pending-commit-interval": {
      "name": "Pending Commit Interval",
      "description": "The maximum time that is allowed to pass while waiting for the remote party\n; to revoke a locally initiated commitment state",
      "default": ""
    },
    "channel-commit-batch-size": {
      "name": "Channel Commit Batch Size",
      "description": "The maximum number of channel state updates that is accumulated before signing\n; a new commitment.",
      "default": ""
    },
    "keep-failed-payment-attempts": {
      "name": "Keep Failed Payment Attempts",
      "description": "Keeps persistent record of all failed payment attempts for successfully\n; settled payments.",
      "default": ""
    },
    "default-remote-max-htlcs": {
      "name": "Default Remote Max HTLCs",
      "description": "The default max_htlc applied when opening or accepting channels. This value\n; limits the number of concurrent HTLCs that the remote party can add to the\n; commitment. The maximum possible value is 483.",
      "default": ""
    },
    "chan-enable-timeout": {
      "name": "Channel Enable Timeout",
      "description": "The duration that a peer connection must be stable before attempting to send a\n; channel update to re-enable or cancel a pending disables of the peer's channels\n; on the network.",
      "default": "19m"
    },
    "chan-disable-timeout": {
      "name": "Channel Disable Timeout",
      "description": "The duration that must elapse after first detecting that an already active\n; channel is actually inactive and sending channel update disabling it to the \n; network. The pending disable can be canceled if the peer reconnects and becomes\n; stable for chan-enable-timeout before the disable update is sent.",
      "default": "20m"
    },
    "chan-status-sample-interval": {
      "name": "Channel Status Sample Interval",
      "description": "The polling interval between attempts to detect if an active channel has become; inactive due to its peer going offline.",
      "default": "1m"
    },
    "height-hint-cache-query-disable": {
      "name": "Height Hit Cache Query Disable",
      "description": "Disable queries from the height-hint cache to try to recover channels stuck in\n; the pending close state. Disabling height hint queries may cause longer chain\n; rescans, resulting in a performance hit. Unset this after channels are unstuck\n; so you can get better performance again.",
      "default": false
    },
    "historicalsyncinterval": {
      "name": "Historical Sync Interval",
      "description": "The polling interval between historical graph sync attempts. Each historical\n; graph sync attempt ensures we reconcile with the remote peer's graph from the\n; genesis block.",
      "default": "1h"
    },
    "ignore-historical-gossip-filters": {
      "name": "Ignore Historical Gossip Filters",
      "description": "If true, will not reply with historical data that matches the range specified\n; by a remote peer's gossip_timestamp_filter. Doing so will result in lower\n; memory and bandwidth requirements.",
      "default": false
    },
    "rejectpush": {
      "name": "Reject Push",
      "description": " If true, lnd will not accept channel opening requests with non-zero push\n; amounts. This should prevent accidental pushes to merchant nodes.",
      "default": false
    },
    "rejecthtlc": {
      "name": "Reject HTLCs",
      "description": "If true, lnd will not forward any HTLCs that are meant as onward payments. This; option will still allow lnd to send HTLCs and receive HTLCs but lnd won't be; used as a hop.",
      "default": false
    },
    "requireinterceptor": {
      "name": "Require Interceptor",
      "description": "If true, all HTLCs will be held until they are handled by an interceptor",
      "default": false
    },
    "stagger-initial-reconnect": {
      "name": "Stagger Initial Reconnect",
      "description": "If true, will apply a randomized staggering between 0s and 30s when\n; reconnecting to persistent peers on startup. The first 10 reconnections will be\n; attempted instantly, regardless of the flag's value",
      "default": false
    },
    "max-cltv-expiry": {
      "name": "Max CLTV Expiry",
      "description": "The maximum number of blocks funds could be locked up for when forwarding\n; payments. (default: 2016)",
      "default": 2016
    },
    "max-channel-fee-allocation": {
      "name": "Max Channel Fee Allocation",
      "description": "The maximum percentage of total funds that can be allocated to a channel's\n; commitment fee. This only applies for the initiator of the channel. Valid\n; values are within [0.1, 1]. (default: 0.5)",
      "default": 0.5
    },
    "max-commit-fee-rate-anchors": {
      "name": "Max Commit Fee Rate Anchors",
      "description": "The maximum fee rate in sat/vbyte that will be used for commitments of\n; channels of the anchors type. Must be large enough to ensure transaction\n; propagation",
      "default": 10
    },
    "dust-threshold": {
      "name": "Dust Threshold",
      "description": "A threshold defining the maximum amount of dust a given channel can have\n; after which forwarding and sending dust HTLC's to and from the channel will\n; fail. This amount is expressed in satoshis.",
      "default": 500000
    },
    "dry-run-migratio": {
      "name": "Dry Run Migration",
      "description": "If true, lnd will abort committing a migration if it would otherwise have been\n; successful. This leaves the database unmodified, and still compatible with the\n; previously active version of lnd.",
      "default": false
    },
    "enable-upfront-shutdown": {
      "name": "Enable Upfront Shutdown",
      "description": "If true, option upfront shutdown script will be enabled. If peers that we open\n; channels with support this feature, we will automatically set the script to\n; which cooperative closes should be paid out to on channel open. This offers the\n; partial protection of a channel peer disconnecting from us if cooperative\n; close is attempted with a different script.",
      "default": false
    },
    "accept-keysend": {
      "name": "Accept Keysend",
      "description": "If true, spontaneous payments through keysend will be accepted.\n; This is a temporary solution until AMP is implemented which is expected to be soon.\n; This option will then become deprecated in favor of AMP.",
      "default": ""
    },
    "keysend-hold-time": {
      "name": "Keysend Hold Time",
      "description": "If non-zero, keysend payments are accepted but not immediately settled. If the\n; payment isn't settled manually after the specified time, it is canceled\n; automatically. [experimental]",
      "default": 0
    },
    "accept-amp": {
      "name": "Accept AMP",
      "description": "If true, spontaneous payments through AMP will be accepted. Payments to AMP\n; invoices will be accepted regardless of this setting.",
      "default": false
    },
    "gc-canceled-invoices-on-startup=true": {
      "name": "Garbage Collect Invoice on Startup",
      "description": "If true, we'll attempt to garbage collect canceled invoices upon start.",
      "default": false
    },
    "gc-canceled-invoices-on-the-fly": {
      "name": "Garbage Collect",
      "description": "If true, we'll delete newly canceled invoices on the fly.",
      "default": false
    },
    "allow-circular-route": {
      "name": "Allow Ciruclar Route",
      "description": "If true, our node will allow htlc forwards that arrive and depart on the same channel.",
      "default": false
    },
    "trickledelay": {
      "name": "Trick Delay",
      "description": "Time in milliseconds between each release of announcements to the network",
      "default": 180000
    },
    "numgraphsyncpeers": {
      "name": "Number Graph Sync Peers",
      "description": "The number of peers that we should receive new graph updates from. This option\n; can be tuned to save bandwidth for light clients or routing nodes.",
      "default": 3
    },
    "prometheus.enable": {
      "name": "Prometheus Enable",
      "description": "If true, lnd will start the Prometheus exporter. Prometheus flags are \n; behind a build/compile flag and are not available by default. lnd must be built \n; with the monitoring tag; `make && make install tags=monitoring` to activate them.",
      "default": false
    },
    "prometheus.listen": {
      "name": "Prometheus Listen",
      "description": "Specify the interface to listen on for Prometheus connections.",
      "default": "0.0.0.0:8989"
    },
    "prometheus.perfhistograms": {
      "name": "Prometheus Perfhistograms",
      "description": "If true, then we'll export additional information that allows users to plot\n; the processing latency, and total time spent across each RPC calls+service.\n; This generates additional memory load for the Prometheus server, and will end\n; up using more disk space over time.",
      "default": ""
    },
    "alias": {
      "name": "Alias",
      "description": "The alias your node will use, which can be up to 32 UTF-8 characters in length.",
      "default": "My Lightning ☇"
    },
    "color": {
      "name": "Color",
      "description": "The color of the node in hex format, used to customize node appearance in\n; intelligence services.",
      "default": "#3399FF"
    }

    
  },
  "bitcoin": {
    "section": "Bitcoin",
    "description": "Bitcoin parameters",
    "bitcoin.active": {
      "name": "Bitcoin Active",
      "description": "If the Bitcoin chain should be active. Atm, only a single chain can be active.",
      "default": true
    },
    "bitcoin.chaindir": {
      "name": "Bitcoin Chaindir",
      "description": "The directory to store the chain's data within.",
      "default": ""
    },
    "bitcoin.mainnet": {
      "name": "Bitcoin Mainnet",
      "description": "Use Bitcoin's main network.",
      "default": true
    },
    "bitcoin.testnet": {
      "name": "Bitcoin Testnet",
      "description": "Use Bitcoin's test network.",
      "default": false
    },
    "bitcoin.regtest": {
      "name": "Bitcoin Regtest",
      "description": " Use Bitcoin's regression test network",
      "default": false
    },
    "bitcoin.signet": {
      "name": "Bitcoin Signet",
      "description": "Use Bitcoin's signet test network",
      "default": false
    },
    "bitcoin.signetchallenge": {
      "name": "Bitcoin Signetchallenge",
      "description": "Connect to a custom signet network defined by this challenge instead of using the global default signet test network -- Can be specified multiple times",
      "default": ""
    },
    "bitcoin.signetseednode": {
      "name": "Bitcoin Signet Seed Node",
      "description": "Specify a seed node for the signet network instead of using the global default signet network seed nodes",
      "default": ""
    },
    "bitcoin.node": {
      "name": "Bitcoin Node",
      "description": "Specify the chain back-end. NOTE: Please note that switching between a full back-end (btcd/bitcoind) and a light back-end (neutrino) is not supported.",
      "default": "btcd",
      "values": [
        "btcd",
        "bitcoind",
        "neutrino"
      ]
    },
     "bitcoin.defaultchanconfs": {
      "name": "Bitcoin Default channel Confirmations",
      "description": "The default number of confirmations a channel must have before it's considered open. We'll require any incoming channel requests to wait this many confirmations before we consider the channel active.",
      "default": 3
    },
    "bitcoin.defaultremotedelay": {
      "name": "Bitcoin Defaultremotedelay",
      "description": "The default number of blocks we will require our channel counterparty to wait; before accessing its funds in case of unilateral close. If this is not set, we; will scale the value according to the channel size.",
      "default": 144
    },
    "bitcoin.maxlocaldelay": {
      "name": "Bitcoin Maxlocaldelay",
      "description": "The maximum number of blocks we will limit the wait that our own funds are encumbered by in the case when our node unilaterally closes. If a remote peer proposes a channel with a delay above this amount, lnd will reject the channel.",
      "default": 2016
    },
    "bitcoin.minhtlc": {
      "name": "Bitcoin Min HTLC",
      "description": "The smallest HTLC we are willing to accept on our channels, in millisatoshi.",
      "default": 1
    },
    "bitcoin.minhtlcout": {
      "name": "Bitcoin Min HTLCL Out",
      "description": "The smallest HTLC we are willing to send out on our channels, in millisatoshi.",
      "default": 1000
    },
    "bitcoin.basefee": {
      "name": "Bitcoin Base Fee",
      "description": "The base fee in millisatoshi we will charge for forwarding payments on our channels.",
      "default": 1000
    },
    "bitcoin.feerate": {
      "name": "Bitcoin Feerate",
      "description": "The fee rate used when forwarding payments on our channels. The total fee charged is basefee + (amount * feerate / 1000000), where amount is the forwarded amount.",
      "default": 1
    },
    "bitcoin.timelockdelta": {
      "name": "Bitcoin Timelock Delta",
      "description": "The CLTV delta we will subtract from a forwarded HTLC's timelock value.",
      "default": 40
    },
    "bitcoin.dnsseed": {
      "name": "Bitcoin DNS Seed",
      "description": "The seed DNS server(s) to use for initial peer discovery. Must be specified as a '<primary_dns>[,<soa_primary_dns>]' tuple where the SOA address is needed for DNS resolution through Tor but is optional for clearnet users. Multiple tuples can be specified, will overwrite the default seed servers. The default seed servers are",
      "default": ""
    }
  },
  "btcd": {
    "section": "Btcd",
    "description": "Btcd Backend Parameters",
    "btcd.dir": {
      "name": "Btcd Directory",
      "description": "The base directory that contains the node's data, logs, configuration file, etc",
      "default": "~/.btcd"
    },
    "btcd.rpchost": {
      "name": "Btcd. RPC Host",
      "description": "The host that your local btcd daemon is listening on. By default, this setting is assumed to be localhost with the default port for the current network.",
      "default": "localhost"
    },
    "btcd.rpcuser": {
      "name": "Btcd RPC User",
      "description": "Username for RPC connections to btcd. By default, lnd will attempt to automatically obtain the credentials, so this likely won't need to be set (other than for simnet mode).",
      "default": ""
    },
    "btcd.rpcpass": {
      "name": "Btcd RPC Password",
      "description": "Password for RPC connections to btcd. By default, lnd will attempt to automatically obtain the credentials, so this likely won't need to be set (other than for simnet mode).",
      "default": ""
    },
    "btcd.rpccert": {
      "name": "Btcd RPC Cert",
      "description": "File containing the daemon's certificate file. This only needs to be set if the node isn't on the same host as lnd.",
      "default": "~/.btcd/rpc.cert"
    },
    "btcd.rawrpccert": {
      "name": "Btcd Raw RPC cert",
      "description": "The raw bytes of the daemon's PEM-encoded certificate chain which will be used to authenticate the RPC connection. This only needs to be set if the btcd node is on a remote host.",
      "default": ""
    }
  },
  "bitcoind": {
    "section": "Bitcoind",
    "description": "Bitcoind Backend Parameters",
    "bitcoind.dir": {
      "name": "bitcoind Directory",
      "description": "The base directory that contains the node's data, logs, configuration file, etc",
      "default": "~/.bitcoind"
    },
    "bitcoind.rpchost": {
      "name": "bitcoind. RPC Host",
      "description": "The host that your local bitcoind daemon is listening on. By default, this setting is assumed to be localhost with the default port for the current network.",
      "default": "localhost"
    },
    "bitcoind.rpcuser": {
      "name": "bitcoind RPC User",
      "description": "Username for RPC connections to bitcoind. By default, lnd will attempt to automatically obtain the credentials, so this likely won't need to be set (other than for simnet mode).",
      "default": ""
    },
    "bitcoind.rpcpass": {
      "name": "bitcoind RPC Password",
      "description": "Password for RPC connections to bitcoind. By default, lnd will attempt to automatically obtain the credentials, so this likely won't need to be set (other than for simnet mode).",
      "default": ""
    },
    "bitcoind.zmqpubrawblock": {
      "name": "bitcoind ZMQ pubrawblock",
      "description": "ZMQ socket which sends rawblock and rawtx notifications from bitcoind. By default, lnd will attempt to automatically obtain this information, so this likely won't need to be set (other than for a remote bitcoind instance).",
      "default": ""
    },
    "bitcoind.zmqpubrawtx": {
      "name": "bitcoind ZMQ pubrawblock",
      "description": "ZMQ socket which sends rawtx notifications from bitcoind.",
      "default": ""
    },
    "bitcoind.rpcpolling": {
      "name": "bitcoind RPC polling",
      "description": "Use bitcoind's rpc interface to get block and transaction notifications instead of using the zmq interface. Only the rpcpolling option needs to be set in order to enable this, the rest of the options can be used to change the default values used for this configuration.",
      "default": false
    },
    "bitcoind.blockpollinginterval": {
      "name": "bitcoind Block Polling Interval",
      "description": "Interval which we use bitcoind rpc to look for new blocks",
      "default": ""
    },
    "bitcoind.txpollinginterval": {
      "name": "bitcoind Transaction Polling Interval",
      "description": "Interval which we use bitcoind rpc to look for new raw txs",
      "default": ""
    },
    "bitcoind.estimatemode": {
      "name": "bitcoind Read Dead Line",
      "description": "Fee estimate mode for bitcoind.",
      "description": {
        "ECONOMICAL": "Economical Mode",
        "CONSERVATIVE": "Conservative Mode"
      },
      "values": [
        "CONSERVATIVE",
        "ECONOMICAL"
      ],
      "default": "CONSERVATIVE"
    }
  },
  "neutrino": {
    "section": "Neutrino",
    "description": "Neutrino Backend Parameters",
    "neutrino.connect": {
      "name": "Neutrino Connect",
      "description": "Connect only to the specified peers at startup. This creates a persistent connection to a target peer. This is recommended as there aren't many neutrino compliant full nodes on the test network yet.",
      "default": ""
    },
    "neutrino.maxpeers": {
      "name": "Neutrino Max Peers",
      "description": "Max number of inbound and outbound peers.",
      "default": ""
    },
    "neutrino.addpeer": {
      "name": "Neutrino Add Peer",
      "description": "Add a peer to connect with at startup.",
      "default": ""
    },
    "neutrino.banduration": {
      "name": "Neutrino Banduration",
      "description": "How long to ban misbehaving peers. Valid time units are {s, m, h}. Minimum 1 second.",
      "default": ""
    },
    "neutrino.banthreshold": {
      "name": "Neutrino Ban Threshold",
      "description": "Maximum allowed ban score before disconnecting and banning misbehaving peers.",
      "default": ""
    },
    "neutrino.assertfilterheader": {
      "name": "Neutrino Assert Filter Header",
      "description": "Optional filter header in height:hash format to assert the state of neutrino's filter header chain on startup. If the assertion does not hold, then the. filter header chain will be re-synced from the genesis block.",
      "default": ""
    },
    "neutrino.useragentname": {
      "name": "Neutrino User Agent Name",
      "description": "Used to help identify ourselves to other bitcoin peers",
      "default": "neutrino"
    },
    "neutrino.useragentversion": {
      "name": "Neutrino User Agent Version",
      "description": "",
      "default": "0.11.0-beta"
    },
    "neutrino.broadcasttimeout": {
      "name": "Neutrino Broad Cast Timeout",
      "description": "The amount of time to wait before giving up on a transaction broadcast attempt.",
      "default": "5s"
    },
    "neutrino.persistfilters": {
      "name": "Neutrino Persist Filters",
      "description": "Whether compact filters fetched from the P2P network should be persisted to disk.",
      "default": false
    },
    "neutrino.validatechannels": {
      "name": "Neutrino Validatechannels",
      "description": "Validate every channel in the graph during sync by downloading the containing block. This is the inverse of routing.assumechanvalid, meaning that for Neutrino the validation is turned off by default for massively increased graph sync performance. This speedup comes at the risk of using an unvalidated view of the network for routing. Overwrites the value of routing.assumechanvalid if Neutrino is used.",
      "default": false
    }
  },
  "autopilot": {
    "section": "Autopilot",
    "description": "Autopilot is a way of automatically opening and managing channels with peers.",
    "autopilot.active": {
      "name": "Autopilot Active",
      "description": "If the autopilot agent should be active or not. The autopilot agent will attempt to automatically open up channels to put your node in an advantageous position within the network graph.",
      "default": false
    },
    "autopilot.maxchannels": {
      "name": "Autopilot Max Channels",
      "description": "The maximum number of channels that should be created.",
      "default": 0
    },
    "autopilot.allocation": {
      "name": "Autopilot Allocation",
      "description": "The fraction of total funds that should be committed to automatic channel establishment. For example 0.6 means that 60% of the total funds available within the wallet should be used to automatically establish channels. The total amount of attempted channels will still respect the maxchannels param.",
      "default": 0
    },
    "autopilot.heuristic": {
      "name": "Autopilot Heuristic",
      "description": "Heuristic to activate, and the weight to give it during scoring. (default:; top_centrality:1)",
      "default": "preferential:1"
    },
    "autopilot.minchansize": {
      "name": "Autopilot Min Channel Size",
      "description": "The smallest channel that the autopilot agent should create",
      "default": 20000
    },
    "autopilot.maxchansize": {
      "name": "Autopilot Max channel Size",
      "description": "The largest channel that the autopilot agent should create",
      "default": 16777215
    },
    "autopilot.private": {
      "name": "Autopilot Private",
      "description": "Whether the channels created by the autopilot agent should be private or not. Private channels won't be announced to the network.",
      "default": false
    },
    "autopilot.minconfs": {
      "name": "Autopilot Minimum Confs",
      "description": "The minimum number of confirmations each of your inputs in funding transactions created by the autopilot agent must have.",
      "default": 1
    },
    "autopilot.conftarget": {
      "name": "Autopilot Confirmation Target",
      "description": "The confirmation target (in blocks) for channels opened by autopilot.",
      "default": 3
    }
  },
  "tor": {
    "section": "Tor",
    "description": "Connect to the lightning network through Tor",
    "tor.active": {
      "name": "Tor Active",
      "description": "; Allow outbound and inbound connections to be routed through Tor.",
      "default":  false
    },
    "tor.skip-proxy-for-clearnet-targets": {
      "name": "Tor Skip Proxy For Clearnet Targets",
      "description": "Allow the node to connect to non-onion services directly via clearnet. This allows the node operator to use direct connections to peers not running behind Tor, thus allowing lower latency and better connection stability.",
      "default":  false
    },
    "tor.socks": {
      "name": "Tor Socks",
      "description": "The port that Tor's exposed SOCKS5 proxy is listening on. Using Tor allows outbound-only connections ",
      "default":  9050
    },
    "tor.dns": {
      "name": "Tor Dns",
      "description": "The DNS server as IP:PORT that Tor will use for SRV queries - NOTE must have TCP resolution enabled. The current active DNS server for Testnet listening is nodes.lightning.directory",
      "default":  ""
    },
    "tor.streamisolation": {
      "name": "Tor Stream Isolation",
      "description": "Enable Tor stream isolation by randomizing user credentials for each connection. With this mode active, each connection will use a new circuit. This means that multiple applications (other than lnd) using Tor won't be mixed in with lnd's traffic.",
      "default":  false
    },
    "tor.control": {
      "name": "Tor Control",
      "description": "The host:port that Tor is listening on for Tor control connections",
      "default":  9051
    },
    "tor.targetipaddress": {
      "name": "Tor Target IP Address",
      "description": "IP address that Tor should use as the target of the hidden service",
      "default":  ""
    },
    "tor.password": {
      "name": "Tor Password",
      "description": "The password used to arrive at the HashedControlPassword for the control port. If provided, the HASHEDPASSWORD authentication method will be used instead of the SAFECOOKIE one.",
      "default":  ""
    },
    "tor.v2": {
      "name": "Tor V2",
      "description": "Automatically set up a v2 onion service to listen for inbound connections",
      "default":  false
    },
    "tor.v3": {
      "name": "Tor V3",
      "description": "Automatically set up a v3 onion service to listen for inbound connections",
      "default":  false
    },
    "tor.privatekeypath": {
      "name": "Tor Private Key Path",
      "description": "The path to the private key of the onion service being created",
      "default":  "/path/to/torkey"
    },
    "tor.watchtowerkeypath": {
      "name": "Tor Watch Tower Key Path",
      "description": "The path to the private key of the watchtower onion service being created",
      "default":  "/path/to/torkey"
    },
    "tor.encryptkey": {
      "name": "Tor Encrypt Key",
      "description": "Instructs lnd to encrypt the private key using the wallet's seed.",
      "default": false
    }
  },
  "watchtower": {
    "section": "Watch Tower",
    "description": "Watchtowers act as a second line of defense in responding to malicious or accidental breach scenarios in the event that the client’s node is offline or unable to respond at the time of a breach, offering greater degree of safety to channel funds.",
    "watchtower.active": {
      "name": "Watchtower Active",
      "description": "Enable integrated watchtower listening on :9911 by default.",
      "default": false
    },
    "watchtower.listen": {
      "name": "Watchtower Listen",
      "description": "Specify the interfaces to listen on for watchtower client connections. One listen address per line. If no port is specified the default port of 9911 will be defaulted",
      "default": ""
    },
    "watchtower.externalip": {
      "name": "Watchtower External IP",
      "description": "Configure the external IP address of your watchtower. Setting this field does not have any behavioral changes to the tower or enable any sort of discovery, however it will make the full URI (pubkey@host:port) available via WatchtowerRPC.GetInfo and `lncli tower info`.",
      "default": ""
    },
    "watchtower.towerdir": {
      "name": "Watchtower Tower Directory",
      "description": "Configure the default watchtower data directory. The default directory is data/watchtower relative to the chosen lnddir. This can be useful if one needs to move the database to a separate volume with more storage.",
      "default": ""
    },
    "watchtower.readtimeout": {
      "name": "Watchtower Read Timeout",
      "description": "Duration the watchtower server will wait for messages to be received before hanging up on client connections.",
      "default": "15s"
    },
    "watchtower.writetimeout": {
      "name": "Watchtower Write Timeout",
      "description": "",
      "default": "15s"
    }
  },
  "wtclient": {
    "section": "Watch Tower Client",
    "description": "Interact with the watchtower client directly to obtain/modify information about the set of registered watchtowers.",
    "wtclient.active": {
      "name": "Wtclient Active",
      "description": "Activate Watchtower Client. To get more information or configure watchtowers",
      "default": false
    },
    "wtclient.sweep-fee-rate": {
      "name": "wtclient Wweep Fee Rate",
      "description": "Specify the fee rate with which justice transactions will be signed. This fee rate should be chosen as a maximum fee rate one is willing to pay in order to sweep funds if a breach occurs while being offline. The fee rate should be specified in sat/byte, the default is 10 sat/byte",
      "default": 10
    }
  },
  "healthcheck": {
    "section": "Health Check",
    "description": "Monitor the liveliness of your node with periodic health checks",
    "healthcheck.chainbackend.attempts": {
      "name": "Health Check Chain Backend Attempts",
      "description": "The number of times we should attempt to query our chain backend before gracefully shutting down. Set this value to 0 to disable this health check",
      "default": 3
    },
    "healthcheck.chainbackend.timeout": {
      "name": "Health Check Chain Backend Timeout",
      "description": "The amount of time we allow a call to our chain backend to take before we fail the attempt. This value must be >= 1s.",
      "default": "10s"
    },
    "healthcheck.chainbackend.backoff": {
      "name": "Health Check Chain Backend Backoff",
      "description": "The amount of time we should backoff between failed attempts to query chain backend. This value must be >= 1s.",
      "default": "30s"
    },
    "healthcheck.chainbackend.interval": {
      "name": "Health Check Chain Backend Interval",
      "description": "The amount of time we should wait between chain backend health checks. This value must be >= 1m.",
      "default": "1m"
    },
    "healthcheck.diskspace.diskrequired": {
      "name": "Health Check Disk Space. Disk Required",
      "description": "The minimum ratio of free disk space to total capacity that we require.",
      "default": 0.1
    },
    "healthcheck.diskspace.attempts": {
      "name": "Health Check Disk Space Attempts",
      "description": "The number of times we should attempt to query our available disk space before gracefully shutting down. Set this value to 0 to disable this health check.",
      "default": 2
    },
    "healthcheck.diskspace.timeout": {
      "name": "Health Check Disk Space Timeout",
      "description": "The amount of time we allow a query for our available disk space to take before we fail the attempt. This value must be >= 1s.",
      "default": "5s"
    },
    "healthcheck.diskspace.backoff": {
      "name": "Health Check Disk Space Backoff",
      "description": "The amount of time we should backoff between failed attempts to query available disk space. This value must be >= 1s.",
      "default": "1m"
    },
    "healthcheck.diskspace.interval": {
      "name": "Health Check Disk Space Interval",
      "description": "The amount of time we should wait between disk space health checks. This value must be >= 1m.",
      "default": "6h"
    },
     "healthcheck.tls.attempts": {
      "name": "Health Check TLS Attempts",
      "description": "The number of times we should attempt to check for certificate expiration before gracefully shutting down. Set this value to 0 to disable this health check.",
      "default": 2
    },
    "healthcheck.tls.timeout": {
      "name": "Health Check TLS Timeout",
      "description": "The amount of time we allow a query for certificate expiration to take before we fail the attempt. This value must be >= 1s.",
      "default": "5s"
    },
    "healthcheck.tls.backoff": {
      "name": "Health Check TLS Backoff",
      "description": "The amount of time we should backoff between failed attempts to query certificate expiration. This value must be >= 1s.",
      "default": "1m"
    },
    "healthcheck.tls.interval": {
      "name": "Health Check TLS Interval",
      "description": "The amount of time we should wait between certificate expiration health checks. This value must be >= 1m.",
      "default": ""
    },
    "healthcheck.torconnection.attempts": {
      "name": "Health Check Tor Connection Attempts",
      "description": "The number of times we should attempt to check our tor connection before gracefully shutting down. Set this value to 0 to disable this health check.",
      "default": 0
    },
    "healthcheck.torconnection.timeout": {
      "name": "Health Check Tor Connection Timeout",
      "description": "he amount of time we allow a call to our tor connection to take before we  fail the attempt. This value must be >= 1s.",
      "default": "10s"
    },
    "healthcheck.torconnection.backoff": {
      "name": "Health Check Tor Connection Backoff",
      "description": "The amount of time we should backoff between failed attempts to check tor connection. This value must be >= 1s.",
      "default": "30s"
    },
    "healthcheck.torconnection.interval": {
      "name": "Health Check Tor Connection Interval",
      "description": "The amount of time we should wait between tor connection health checks. This value must be >= 1m.",
      "default": "1m"
    },
    "healthcheck.remotesigner.attempts": {
      "name": "Health Check Remote Signer Attempts",
      "description": "The number of times we should attempt to check our remote signer RPC connection before gracefully shutting down. Set this value to 0 to disable this health check.",
      "default": 0
    },
    "healthcheck.remotesigner.timeout": {
      "name": "Health Check Remote Signer Timeout",
      "description": "The amount of time we allow a call to our remote signer RPC connection to take before we fail the attempt. This value must be >= 1s.",
      "default": "1s"
    },
    "healthcheck.remotesigner.backoff": {
      "name": "Health Check Remote Signer Backoff",
      "description": "The amount of time we should backoff between failed attempts to check remote signer RPC connection. This value must be >= 1s.",
      "default": "1s"
    },
    "healthcheck.remotesigner.interval": {
      "name": "Health Check Remote Signer Interval",
      "description": "The amount of time we should wait between remote signer RPC connection health checks. This value must be >= 1m.",
      "default": ""
    }
  },
  "signrpc": {
    "section": "Sign RPC",
    "description": "Signing RPC Parameters",
    "signrpc.signermacaroonpath": {
      "name": "Signer Macaroon Path",
      "description": "Path to the signer macaroon.",
      "default": "~/.lnd/data/chain/bitcoin/simnet/signer.macaroon"
    }
  },
  "walletrpc": {
    "section": "Wallet RPC",
    "description": "Wallet RPC Parameters",
    "walletrpc.walletkitmacaroonpath": {
      "name": "Wallet Kit Macaroon Path",
      "description": "Path to the wallet kit macaroon.",
      "default": "~/.lnd/data/chain/bitcoin/simnet/walletkit.macaroon"
    }
  },
   "chainrpc": {
    "section": "Chain RPC",
    "description": "Chain RPC Parameters",
    "chainrpc.notifiermacaroonpath": {
      "name": "Notifier Macaroon Path",
      "description": "Path to the chain notifier macaroon.",
      "default": "~/.lnd/data/chain/bitcoin/simnet/chainnotifier.macaroon"
    }
  },
  "routerrpc": {
    "section": "Router RPC",
    "description": "Router RPC Parameters",
    "routerrpc.minrtprob": {
      "name": "Minimum Route Probability",
      "description": "Minimum required route success probability to attempt the payment",
      "default": 0.01
    },
    "routerrpc.apriorihopprob": {
      "name": "Apriori Hop prob",
      "description": "Assumed success probability of a hop in a route when no other information is available.",
      "default": 0.6
    },
    "routerrpc.aprioriweight": {
      "name": "Apriori weight",
      "description": "Weight of the a priori probability in success probability estimation. Valid values are in [0, 1].",
      "default": 0.3
    },
    "routerrpc.penaltyhalflife": {
      "name": "Penalty Half Life",
      "description": "Defines the duration after which a penalized node or channel is back at 50% probability",
      "default": "1h0m0s"
    },
    "routerrpc.attemptcost": {
      "name": "Attempt Cost",
      "description": "The (virtual) fixed cost in sats of a failed payment attempt",
      "default": ""
    },
    "routerrpc.attemptcostppm": {
      "name": "Attempt Cost PPM",
      "description": "The (virtual) proportional cost in ppm of the total amount of a failed payment attempt",
      "default": 1000
    },
    "routerrpc.maxmchistory": {
      "name": "Maximum Mission Control History",
      "description": "The maximum number of payment results that are held on disk by mission control",
      "default": 1000
    },
    "routerrpc.mcflushinterval": {
      "name": "Mission Control Flush Interval",
      "description": "The time interval with which the MC store state is flushed to the DB.",
      "default": "1m"
    },
    "routerrpc.routermacaroonpath": {
      "name": "Router Macaroon Path",
      "description": "Path to the router macaroon",
      "default": "~/.lnd/data/chain/bitcoin/simnet/router.macaroon"
    }
  },
  "workers": {
    "section": "Workers",
    "description": "Section for controlling concurrency",
    "workers.read": {
      "name": "Workers Read",
      "description": "Maximum number of concurrent read pool workers. This number should be proportional to the number of peers.",
      "default": 100
    },
    "workers.write": {
      "name": "Workers Write",
      "description": "Maximum number of concurrent write pool workers. This number should be proportional to the number of CPUs on the host.",
      "default": 8
    },
    "workers.sig": {
      "name": "Workers Sig",
      "description": "Maximum number of concurrent sig pool workers. This number should be proportional to the number of CPUs on the host.",
      "default": 8
    }
  },
  "caches": {
    "section": "Caches",
    "description": "",
    "caches.reject-cache-size": {
      "name": "Reject Cache Size",
      "description": "Maximum number of entries contained in the reject cache, which is used to speed up filtering of new channel announcements and channel updates from peers. Each entry requires 25 bytes.",
      "default": 50000
    },
    "caches.channel-cache-size": {
      "name": "Channel Cache Size",
      "description": "Maximum number of entries contained in the channel cache, which is used to reduce memory allocations from gossip queries from peers. Each entry requires roughly 2Kb.",
      "default": 20000
    },
    "caches.rpc-graph-cache-duration": {
      "name": "RPC Graph Cache Duration",
      "description": "The duration that the response to DescribeGraph should be cached for. Setting the value to zero disables the cache.",
      "default": "1m"
    }
  },
  "protocol": {
    "section": "Protocol",
    "description": "Protocol Level Parameters",
    "protocol.wumbo-channels": {
      "name": "Wumbo Channels",
      "description": "If set, then lnd will create and accept requests for channels larger than 0.16 BTC",
      "default": false
    },
    "protocol.no-anchors": {
      "name": "No-anchors",
      "description": " Set to disable support for anchor commitments. If not set, lnd will use anchor channels by default if the remote channel party supports them. Note that lnd will require 1 UTXO to be reserved for this channel type if it is enabled.",
      "default": false
    },
    "protocol.no-script-enforced-lease": {
      "name": "No Script Enforced Lease",
      "description": "Set to disable support for script enforced lease channel commitments. If not set, lnd will accept these channels by default if the remote channel party proposes them. Note that lnd will require 1 UTXO to be reserved for this channel type if it is enabled.",
      "default": false
    },
    "protocol.option-scid-alias": {
      "name": "Option Short Channel Alias",
      "description": "Set to enable support for option_scid_alias channels, which can be referred to by an alias instead of the confirmed ShortChannelID. Additionally, is needed to open zero-conf channels.",
      "default": false
    },
    "protocol.zero-conf": {
      "name": "Zero Conf",
      "description": "Set to enable support for zero-conf channels. This requires the option-scid-alias flag to also be set.",
      "default": false
    },
    "protocol.no-any-segwit": {
      "name": "No Any Segwit",
      "description": "Set to disable support for using P2TR addresses (and beyond) for co-op closing.",
      "default": false
    }
  }
}